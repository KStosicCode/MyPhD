setwd("~/training/zelfgegeven/single-cell/Dalia/BasicScript")

# Load packages ####
library(Seurat)
library(scater)
library(ggvenn)
library(ggpubr)
library(dplyr)

seuratObj <- readRDS("seuratObj0.rds")
data.RNA <- readRDS("SmallRNAmatrix.rds")
data.RNA <- readRDS("RNAClean.rds")

# Load data ####
## Read expression matrices generated by Cellranger
### Kodovi za staru vezrziju Cellrangera (Cellranger v2):
# rawData <- Read10X("Citeseq_mouse_GBM/filtered_gene_bc_matrices_mex/mm10")
# rawData <- as.matrix(rawData)

### Cellranger v3+
?Read10X
data <- Read10X("Citeseq_mouse_GBM/filtered_feature_bc_matrix")
#label the assays
#GE umesto GeneExpression i AB za deo vezan za Ab
names(data) <- c("GE","AB") 
#convert to matrix (posto su do sada bili poseban vid matrice)
data.RNA <- as.matrix(data$GE) #OVO JE PRE> VELIKO< NEMOJ DA KLIKCES NA NJEGA
data.AB <- as.matrix(data$AB)
#remove large variables
rm(data)
#save as R object
saveRDS(data.RNA,file="RNAasmatrix.rds")

### Read h5-file generated by Cellranger v2
# rawData <- Read10X_h5("Citeseq_mouse_GBM/filtered_gene_bc_matrices_h5.h5")

### Read h5-file generated by Cellranger v3+
# rawData <- Read10X_h5("Citeseq_mouse_GBM/filtered_feature_bc_matrix.h5")

## Clean data
#retrieve counts from matrix
data.RNA[1:5,1:5]

#calculate percentage of zero counts
total.zeros <- sum(data.RNA==0) #vratice boolean-e 
total.counts <- nrow(data.RNA) * ncol(data.RNA)
(total.zeros/total.counts) * 100 #dobije se 92,44%, tj. toliki % cine nule, mada je
                                 #ovaj % manje-vise ocekivan kod SingleCell analize

#calculate number of expressed genes / cell
cellCounts <- apply(data.RNA,2,function(x) sum(x > 0)) #2 znaci da se fokusira na
                                                       #kolone, posto su geni
                                                       #redovi, a kolone celije
cellCounts[1:5] #za prvih 5 cel. pokazuje koliko je gena eksprimirano u njima

#remove cells with less than 200 expressed genes
dim(data.RNA) #28692 je br. redova (gena), a 28284 je br. kolona (celija)
data.RNA <- data.RNA[,cellCounts>=200] #cellCounts je varijabla iz prethodnog 
                                       #koraka
data.AB <- data.AB[,cellCounts>=200] 
dim(data.RNA) #br. redova ce ostati isti, jer je to br. gena, samo ce se br. kolona
              #s<ti
dim(data.AB) #ovde br. redova nece biti kao za data.RNA, zato sto ovde redovi nisu
             #geni, ovo su Ab, ali mora i ovde da se uradi redukcija, kako bi br.
             #cel. ostao isti i za data.RNA i za data.AB

#calculate number of expressed cells / gene
geneCounts <- apply(data.RNA,1,function(x) sum(x > 0)) #jedino se menja da umesto
                                                       #2 se pise 1, zato sto se 
                                                       #sada fokus baca na redove,
                                                       #a ne na kolone
geneCounts[1:5]

#remove genes that are expressed in less than 3 cells
data.RNA <- data.RNA[geneCounts>=3,] #cellCounts je isao posle zareza, a geneCounts
                                     #posle;
                                     #cellCounts je zbog br.cel. bilo bitno 
                                     #primeniti i na RNK i na Ab, dok je geneCounts
                                     #okej samo za RNK
dim(data.RNA)


head(rownames(data.RNA)) #Mrpl15
rownames(data.RNA)[1] #Mrpl15
head(colnames(data.RNA)) #AAACCCACAAGCGCTC-1
colnames(data.RNA)[1] #AAACCCACAAGCGCTC-1
head(data.RNA[1,1]) #0
nrow(data.RNA)*ncol(data.RNA) #495.509.458
sum(data.RNA == 0) #434.223.444
data.RNA["Xcr1",2] #0
data.RNA["Xcr1",2] > 0 #dace FALSE

#remove large variables
rm(total.counts)
rm(total.zeros)
rm(cellCounts)
rm(geneCounts)
rm(TGC)

#save as R object
saveRDS(data.RNA,file="RNAclean.rds")
#data.RNA <- readRDS("RNAclean.rds")

# Convert to SingleCellExperiment object ####
?SingleCellExperiment
sce <- SingleCellExperiment(assays=list(counts=data.RNA)) #lista veceg br. matrica

#remove large variables
rm(data.RNA)

#add grouping variable: which sample does cell come from?
head(colnames(sce))
label <- substr(colnames(sce),18,18) #substr() generise tekst, tako da ce umesto
                                     #1 i 2 da vrati "1" i "2", tako da ce posle
                                     #morati da se koristi as.numeric()
names <- c("KO","WT")
colData(sce)$sample <- names[as.numeric(label)] #as.numeric zbog substr()
head(colData(sce)) #colData u sustini na samom pocetku nema nista osim imena cel.,
                   #tj. barkodova, a onda ga build up-ujemo, dodavanjem kolona, 
                   #kao sto su sample, ID, batch itd.

# Number of cells for every sample
table(colData(sce)$sample)
#KO:15771 - WT:11908

# Quality control of cells user scater ####
## Identify mitochondrial transcripts
?grepl
is.mito <- grepl("^mt-",rownames(sce),ignore.case=TRUE) #^ je znak koji znaci da se
                                                        #krene od bilo cega sto 
                                                        #pocinje sa mt, a nece biti
                                                        #razlike izmedju velikih MT
                                                        #(kod ljudi) i malih mt 
                                                        #(kod miseva) slova
sum(is.mito) #daje ukupan broj mt gena koji su prisutni
rownames(sce)[is.mito] #vratice imena prisutnih mt gena

is.mito <- grepl("nd4",rownames(sce),ignore.case=TRUE) #u slucaju da se nd4 (ili 
                                                       #neki drugi gen) postavi kao
                                                       #kontrola

## Calculate QC metrics per cell
?addPerCellQC
sce <- addPerCellQC(sce,subsets=list(Mt=is.mito)) #rezultati ovog QC-a idu u
                                                  #colData() automatski, bez da se
                                                  #R-u 
sce <- addPerCellQC(sce)
#quality metrics are added to coldata
head(colData(sce),2) #sum je library size, detected je br.eksprimiranih gena, a
                     #Mt_percent je % mt gena; ali je lakse da se promene imena u
                     #u malo > informativna imena u sledecem koraku
#rename quality metrics
names(colData(sce))[c(2,3,6)] <- c("nUMI","nGene","mito") #ovo vazi kada su u
                                                          #pitanju dva uzorka, ali
                                                          #kada imas samo jedan 
                                                          #uzorak onda nece 
                                                          #postojati kolona u kojoj
                                                          #je navedena razlika 
                                                          #izmedju tipa KO i WT,
                                                          #odnosno C i T
#Make sure you change the right columns

# Detect outliers cells using scater ####
## UMI counts per cell
?isOutlier
#identify cells with very low counts
colData(sce)$nUMI.out.low <- isOutlier(colData(sce)$nUMI,
                                       nmads=3,
                                       type="lower",
                                       log=TRUE) #nmad je br. devijacija od
                                                 #medijane koji se dozvoljava, tako
                                                 #da su outlieri samo oni van tog
                                                 #opsega; type daje sansu da se
                                                 #definise na kojoj strani
                                                 #raspodele da se traze outlieri,
                                                 #pa se u ovom slucaju traze samo
                                                 #na levoj strani, tj. tamo gde su
                                                 #oni koji imaju bas mali library
                                                 #size
#identify cells with very high counts
colData(sce)$nUMI.out.high <- isOutlier(colData(sce)$nUMI,
                                        nmads=3,
                                        type="higher",
                                        log=TRUE)
#How many outliers?
sum(colData(sce)$nUMI.out.low)
sum(colData(sce)$nUMI.out.high)
sum(colData(sce)$nUMI.out.low | colData(sce)$nUMI.out.high)

## Number of expressed genes per cell
colData(sce)$nGene.out.low <- isOutlier(colData(sce)$nGene,
                                        nmads=3,
                                        type="lower",
                                        log=TRUE) 
colData(sce)$nGene.out.high <- isOutlier(colData(sce)$nGene,
                                         nmads=3,
                                         type="higher",
                                         log=TRUE) 
sum(colData(sce)$nGene.out.low | colData(sce)$nGene.out.high)
sum(colData(sce)$nGene.out.low)
sum(colData(sce)$nGene.out.high)

## Mitochondrial count percentages
colData(sce)$mito.out.high <- isOutlier(colData(sce)$mito,
                                        nmads=3,
                                        type="higher") 
sum(colData(sce)$mito.out.high)

## Create histograms
#create data frame for plotting
metaData <- as.data.frame(colData(sce))
head(metaData)
ggplot(metaData,aes(nUMI)) + 
  geom_histogram(binwidth=100) + 
  xlab("Count depth (total UMI count)") +
  ylab("Frequency") +
  ggtitle("Histogram of total UMI count per cell") + 
  theme_bw()

#calculate threshold used for outliers on number of genes
cut.nGene <- 2^(median(log2(metaData$nGene)) -
                  3*mad(log2(metaData$nGene),na.rm=TRUE)) #cutoff vrednost

ggplot(metaData,aes(nGene)) + 
  geom_histogram(binwidth=20) +
  xlab("Number of Genes") +
  ylab("Frequency") +
  ggtitle("Histogram of number of genes per cell") + 
  geom_vline(xintercept=cut.nGene,color="red") +
  theme_bw() #xintercept je = ovoj varijabli koja je uvedena u prethodnom koraku

#calculate threshold used for outliers on mito transcripts
cut.mito <- median(metaData$mito) + 
  3*mad(metaData$mito,na.rm=TRUE) #cutoff vrednost

ggplot(metaData,aes(mito)) + 
  geom_histogram(binwidth=0.1) +
  xlab("% Mitochondrial counts") +
  ylab("Frequency") +
  ggtitle("Histogram of % mitogenes per cell") +
  geom_vline(xintercept=cut.mito,color="red") +
  theme_bw()

## Create violin plots 
###Before filtering
ggplot(metaData,aes("",nUMI)) +
  geom_jitter(height=0,width=0.3,aes(color=nUMI.out.low)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Total UMI counts per cell") +
  theme_classic()

ggplot(metaData,aes("",nGene)) +
  geom_jitter(height=0,width=0.3,aes(color=nGene.out.low)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Number of genes per cell") +
  theme_classic()

ggplot(metaData,aes("",mito)) +
  geom_jitter(height=0,width=0.3,aes(color=mito.out.high)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("% mitogenes per cell") +
  theme_classic()

###After filtering
#identify cells to keep
non.out <- !(metaData$nUMI.out.low | 
               metaData$nUMI.out.high | 
               metaData$nGene.out.low | 
               metaData$nGene.out.high | 
               metaData$mito.out.high)
metaData.filtered <- metaData[non.out,] #nece doci do uklanjanja outliera iz
                                        #sce, nego samo iz metaData
dim(metaData.filtered)

ggplot(metaData.filtered,aes("",nUMI)) +
  geom_jitter(height=0,width=0.3,aes(color=nUMI.out.low)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Total UMI counts per cell after filtering") +
  theme_classic()

ggplot(metaData.filtered,aes("",nGene)) +
  geom_jitter(height=0,width=0.3,aes(color=nGene.out.low)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Number of genes per cell after filtering") +
  theme_classic()

ggplot(metaData.filtered,aes("",mito)) +
  geom_jitter(height=0,width=0.3,aes(color=mito.out.high)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("% mito genes per cell after filtering") +
  theme_classic()

## Create Venn diagram 
ggvenn(list(nGene=rownames(metaData[metaData$nGene.out.low,]),
            mito=rownames(metaData[metaData$mito.out.high,])),
       fill_color=c("green","orange"),show_percentage=FALSE) #ovaj korak se radi
                                                             #zato sto se dosta
                                                             #preklapaju u slucaju
                                                             #br.eksprimiranih gena
                                                             #i br. mt gena

## Remove outliers from sce
#mito and ngenes outliers are the same cells
keep <- !(metaData$mito.out.high) 
sce <- sce[,keep] 
dim(sce)

label <- substr(colnames(sce),18,18)  
names <- c("KO","WT")  
colData(sce)$sample <- names[as.numeric(label)] 

sce2
label <- substr(colnames(sce2),18,18)  
names <- c("C","T") #u slucaju da ne postoje br., nego tekst
colData(sce2)$treatment <- ifelse(label == "C","control","treated")
colData(sce2)$treatment <- ifelse(label == "1","control","treated")
sum(is.mito)
is.ribo <- grepl("^RP[SL]",row.names(sce),ignore.case = TRUE)
sum(is.ribo)
sce2 <- addPerCellQC(sce2,subsets=list(Mt=is.mito,
                                     Rb=is.ribo))

#remove large variables (wait until after questions)
rm(metaData.filtered)
rm(metaData)
rm(keep)
rm(non.out)

#save to R object
saveRDS(sce,file="sceUni.rds")
 
# Multivariate outlier detection by PCA ####
#define metrics to use in PCA
varsToUse <- c("nUMI","nGene","mito")
library("robustbase")
? runColDataPCA
sce <- runColDataPCA(sce,
                     variables=varsToUse,
                     outliers=TRUE) #poslednji argument naglasava da zelis da se
                                    #detektuju i outlieri, a oni ce automatski da
                                    #da se svrstaju u kolonu outlier u colData
#How many outliers?
sum(colData(sce)$outlier)

## Draw PCA plot and color outliers
reducedDims(sce) #reducedDims() omogucava da se pristupi rezultatima Dimensional
                 #analiza, na istom je hijerarhijskom nivou kao colData(), samo sto
                 #colData() 

?plotReducedDim
plotReducedDim(sce,dimred="PCA_coldata",colour_by="outlier") #kolona outlier je 
                                                             #generisana 
                                                             #zahvaljujuci
                                                             #runColDataPCA()

## Violin plot 
###Before filtering
metaData <- as.data.frame(colData(sce))
ggplot(metaData,aes("",nUMI)) +
  geom_jitter(height=0,width=0.3,aes(color=outlier)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Total UMI counts per cell") +
  theme_classic() 

ggplot(metaData,aes("",nGene)) +
  geom_jitter(height=0,width=0.3,aes(color=outlier)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Number of genes per cell") +
  theme_classic()

###After filtering
non.out <- !(metaData$outlier)
metaData.filtered <- metaData[non.out,]
dim(metaData.filtered)

ggplot(metaData.filtered,aes("",nUMI)) +
  geom_jitter(height=0,width=0.3,aes(color=outlier)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Total UMI counts per cell") +
  theme_classic()

ggplot(metaData.filtered,aes("",nGene)) +
  geom_jitter(height=0,width=0.3,aes(color=outlier)) +
  geom_violin(fill="gray80",alpha=0.5) +
  scale_color_manual(values=c("#00BFC4","#F8766D")) + 
  ggtitle("Number of genes per cell") +
  theme_classic()

## Remove outliers
keep <- !(metaData$outlier) 
sce <- sce[,keep] 
dim(sce)

# Save sce object to file ####
saveRDS(sce,file="sce.rds")

#remove large variables
rm(list=ls())

# Create Seurat object ####
#Seurat ne moze da radi sa sce, vec mu treba SeuratObject, tako da prvo mora sce da
#se konvertuje u matricu, a onda matrica u SeuratOBject

#rowData(), colData(), assays() i reducedDims() su funkcije kojima moze da se 
#pristupi odredjenim grupama podataka unutar SingleCellExperimenta, dok kod 
#SeuratObjecta ne postoje funkcije tog tipa, vec se koriste so@assays, so@meta.data
#i so@reductions

#U slucaju Seurat objekata, moguce je da postoji > br. za assays, jer pored RNK,
#ovde dolaze u obzir i recimo Ab

#import filtered sce
sce <- readRDS("sce.rds")

#retrieve required data (vracanje podataka koje zelis da ubacis u SeuratObject)
counts <- counts(sce) #counts() je isto sto i assays()
metaData <- colData(sce) 

#remove large variables
rm(sce)

?CreateSeuratObject
seuratObj <- CreateSeuratObject(counts=counts)
?AddMetaData
seuratObj <- AddMetaData(seuratObj,as.data.frame(metaData)) #metaData mora da se
                                                            #konvertuje u df

#remove large variables
rm(counts)

## Explore Seurat object
seuratObj@assays

#For functional analysis later save background
#saveRDS(rownames(seuratObj),file="background.rds")

# Normalization ####
?NormalizeData #Normalized Data Matrix ce da se pojavi u delu koji se zove data
seuratObj <- NormalizeData(seuratObj) #zbog (velikih) razlika u library sizes, pa
                                      #cel. nisu comparable, a normalizacija ce ih
                                      #uciniti takvim da budu comparable, a usput
                                      #delimicno (, ali ne potpuno) utice na 
                                      #s<ivanje variranja vrednosti varijanse 
                                      #(usled toga sto se za normalizaciju koristi
                                      #logaritmovanje); sto se konkretno detaljne
                                      #borbe protiv velikih razlika u varijansama
                                      #tice, NormalizeData() ce samo da, usled
                                      #logaritmovanja, suzi taj opseg, ali nece se
                                      #detaljno pobrinuti za sve, jer se ova f-ja
                                      #mahom zasniva na normalizaciji na osnovu
                                      #library sizes; a razlika koja je ostala u 
                                      #slucaju variranja vrednosti varijansi ce
                                      #da bude resena uz pomoc vst
saveRDS(seuratObj,file="seuratObj1.rds")

#retrieve raw and normalized counts
seuratObj@assays$RNA@counts[1:5,1:10]
seuratObj@assays$RNA@data[1:5,1:10]

#create histogram of raw counts
ggplot(seuratObj@meta.data,aes(nUMI)) + 
  geom_histogram(bins=60)

#create histogram of normalized counts
counts.norm <- as.matrix(seuratObj@assays$RNA@data)
nUMILN <- data.frame(nUMI=colSums(counts.norm))
ggplot(nUMILN,aes(nUMI)) + geom_histogram(bins=60)
rm(counts.norm)

# Find highly variable genes ####
?FindVariableFeatures
seuratObj <- FindVariableFeatures(seuratObj)

#retrieve variable genes
length(VariableFeatures(seuratObj))
head(VariableFeatures(seuratObj))
head(HVFInfo(seuratObj))

#plot variable genes
VariableFeaturePlot(seuratObj)

# Scaling ####
?ScaleData
seuratObj <- ScaleData(seuratObj)

#retrieve scaled counts
seuratObj@assays$RNA@scale.data[1:5,1:4]

# PCA ####
?RunPCA
seuratObj <- RunPCA(seuratObj,nfeatures.print=10)

#retrieve results of PCA
seuratObj@reductions$pca@cell.embeddings[1:5,1:5]
seuratObj@reductions$pca@feature.loadings[1:5,1:5]

#PCA plot
DimPlot(seuratObj,reduction="pca",group.by="sample")

# Heat maps of the PCs ####
?DimHeatmap 
DimHeatmap(seuratObj,dims=1:12,cells=500,balanced=TRUE)
DimHeatmap(seuratObj,dims=13:24,cells=500,balanced=TRUE)
DimHeatmap(seuratObj,dims=25:36,cells=500,balanced=TRUE)

# Elbow plot of the PCs ####
?ElbowPlot
ElbowPlot(seuratObj,ndims=50)

# Clustering ####
#How many PCs to use

## Building kNN/SNN graph
?FindNeighbors
seuratObj <- FindNeighbors(seuratObj,dims=1:30)

#names for graphs?
names(seuratObj@graphs)

## Graph-based clustering
?FindClusters
#set resolution
resToUse <- 0.1
seuratObj <- FindClusters(seuratObj,
                          resolution=resToUse,
                          graph.name="RNA_snn") 

#retrieve cluster info
head(seuratObj@meta.data) 

#After testing several resolutions, visualize results
library(clustree)
clustree(seuratObj@meta.data,prefix="RNA_snn_res.")
#Stability index measures the stability of clusters across resolutions 
clustree(seuratObj@meta.data,prefix="RNA_snn_res.",
         node_colour="sc3_stability")

# Create tSNE plot ####
?RunTSNE
seuratObj <- RunTSNE(seuratObj,
                     dims=1:30,
                     check_duplicates=FALSE)

#create tSNE plot
DimPlot(seuratObj,
        reduction="tsne",
        label=TRUE,
        label.size=8,
        pt.size=2) + 
  NoLegend()

DimPlot(seuratObj,
        reduction="tsne",
        pt.size=2,
        group.by="sample")

# Create UMAP plot ####
?RunUMAP
#n.neighbors matches k.param in FindNeighbors()
seuratObj <- RunUMAP(seuratObj,dims=1:30,n.neighbors=20)

DimPlot(seuratObj,group.by="sample")

#Visualize outliers if you haven't removed them  
DimPlot(seuratObj,group.by="mito.out.high")
FeaturePlot(seuratObj,feature="nUMI")

DimPlot(seuratObj,label=TRUE,label.size=8) + 
  NoLegend() + 
  ggplot2::ggtitle(label="UMAP_on_PCA")

# Interpret the clustering ####
#specify which clustering and use these cluster numbers 
Idents(seuratObj) <- seuratObj@meta.data$RNA_snn_res.0.8
tab <- table(seuratObj@meta.data$sample,
      seuratObj@meta.data$seurat_clusters)
write.table(tab,file="table.txt",quote=FALSE)
table(seuratObj@active.ident)

p6 <- DimPlot(seuratObj,label=TRUE) + NoAxes() + NoLegend()
p7 <- DimPlot(seuratObj,group.by="sample") + NoAxes()
ggarrange(p6,p7)

# Save Seurat object ####
saveRDS(seuratObj,file="seuratObj.rds")  


